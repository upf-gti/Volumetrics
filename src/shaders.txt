\shaders
volumetric_default vertex.vs volumetric_default.fs
volumetric_xray vertex.vs volumetric_xray.fs
volumetric_mip vertex.vs volumetric_mip.fs
debug_volumetric_jittering vertex.vs debug_volumetric_jittering.fs
volumetric_depth vertex.vs volumetric_depth.fs

\vertex.vs
#version 300 es
precision highp float;
in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
out vec3 v_pos;
out vec3 v_normal;
out vec2 v_coord;
uniform vec3 u_dimensions;
uniform mat4 u_mvp;
void main() {
    v_pos = u_dimensions * a_vertex.xyz;
    v_coord = a_coord;
    v_normal = a_normal;
    gl_Position = u_mvp * vec4(v_pos,1.0);
}

\fragment_headers_utils
#version 300 es
precision highp float;
precision highp sampler3D;
in vec3 v_pos;
in vec3 v_normal;
in vec2 v_coord;
out vec4 color;
uniform vec3 u_eye;
uniform vec3 u_position;
uniform vec3 u_dimensions;
uniform vec3 u_resolution;
uniform vec4 u_background;
uniform sampler2D u_jittering_texture;
uniform sampler2D u_tf_texture;
uniform sampler3D u_volume_texture;
uniform float u_intensity;
uniform float u_levelOfDetail;
uniform mat4 u_mvp;
uniform mat4 u_imvp;

/* Return point where the ray enters the box. If the ray originates inside the box it returns the origin. */
vec3 rayOrigin(in vec3 ro, in vec3 rd){
    if(abs(ro.x) <= 1.0 && abs(ro.y) <= 1.0 && abs(ro.z) <= 1.0) return ro;
    vec3 ip;
    vec3 sides;
    /* Only one these sides can hold the ray origin. The other faces will never hold it */
    sides = vec3(-sign(rd.x),-sign(rd.y),-sign(rd.z));
    for(int i=0; i<3; i++){
        float c = (sides[i] - ro[i]) / rd[i];
        ip[i] = sides[i];
        ip[(i+1)%3] = c*rd[(i+1)%3]+ro[(i+1)%3];
        ip[(i+2)%3] = c*rd[(i+2)%3]+ro[(i+2)%3];
        if(abs(ip[(i+1)%3]) <= 1.0 && abs(ip[(i+2)%3]) <= 1.0) break;
    }
    return ip;
}

/* Better voxel interpolation from www.iquilezles.org/www/articles/texture/texture.htm */
vec4 getVoxel( in vec3 p ){
    p = p*u_resolution + 0.5;
    
    vec3 i = floor(p);
    vec3 f = p - i;
    f = f*f*f*(f*(f*6.0-15.0)+10.0);
    p = i + f;
    
    p = (p - 0.5)/u_resolution;
    return texture( u_volume_texture, p );
}

float jitteringFactor( vec2 p ){
    return texture(u_jittering_texture, p.xy/100.0).x;
}

\fragment_init
/* Compute ray origin and direction */
    vec3 ro = u_eye - u_position;
    vec3 re = v_pos;
    vec3 rd = re - ro;
    
/* Transform ray to volume space [-1,1] */
    ro = ro / u_dimensions;
    rd = rd / u_dimensions;
    re = re / u_dimensions;
    
/* Compute ray origin as a point on the volume space */
    ro = rayOrigin(ro, rd);

    vec4 cdest = vec4(0.0,0.0,0.0,0.0);
    vec3 rs = ro;   //Ray sample
    rd = normalize(rd) * (1.0/ u_levelOfDetail);

\fragment_postinit_jittering
    //Introduce an offset in the ray starting position along the ray direction
    ro = ro - rd*jitteringFactor(gl_FragCoord.xy);

\fragment_interpolation
    vec3 voxs = (rs + vec3(1.0))/2.0;
    float f = texture( u_volume_texture, voxs ).x;

\fragment_interpolation_better
    vec3 voxs = (rs + vec3(1.0))/2.0;
    float f = getVoxel(voxs).x;

\fragment_classification_direct
    vec4 csrc = vec4(f,f,f,f);

\fragment_classification_transfer_function
    vec4 csrc = texture( u_tf_texture, vec2(f,0.0) );

\fragment_compositing_basic
    csrc = vec4(csrc.xyz * csrc.w, csrc.w); //transparency, applied this way to avoid color bleeding
    cdest = csrc * (1.0 - cdest.w) + cdest; //compositing with previous value

\fragment_compositing_xray
    cdest = csrc * (1.0 - cdest.w) + cdest;

\fragment_compositing_mip
    if(csrc.w > cdest.w){
        cdest = csrc;
    }

\fragment_debug_exit_point
    color = vec4(abs(re.x) == 1.0 ? 1.0 : 0.0, abs(re.y) == 1.0 ? 1.0 : 0.0, abs(re.z) == 1.0 ? 1.0 : 0.0, 1.0);

\fragment_debug_entry_point
    color = vec4(abs(ro.x) == 1.0 ? 1.0 : 0.0, abs(ro.y) == 1.0 ? 1.0 : 0.0, abs(ro.z) == 1.0 ? 1.0 : 0.0, 1.0);

\fragment_debug_entry_abs
    color = vec4(abs(ro.x), abs(ro.y), abs(ro.z), 1.0);

\fragment_debug_distance_entry_exit
    color = 0.1*vec4(distance(ro,re), distance(ro,re), distance(ro,re), 1.0);

\fragment_debug_position_entry
    color = vec4(abs(ro).xyz, 1.0);

\fragment_debug_jittering_intensity
    color = vec4(jitteringFactor(gl_FragCoord.xy), jitteringFactor(gl_FragCoord.xy), jitteringFactor(gl_FragCoord.xy), 1.0);

\volumetric_default.fs
#import "fragment_headers_utils"

void main() {
    #import "fragment_init"
    #import "fragment_postinit_jittering"
        
    /* Use raymarching algorithm */
    for(int i=0; i<100000; i++){
        vec3 absrs = abs(rs);
        if(i > 1 && (absrs.x > 1.0 || absrs.y > 1.0 || absrs.z > 1.0)) break;
		
		/* Interpolation */
        #import "fragment_interpolation_better"
        
        /* Classification */
        #import "fragment_classification_transfer_function"
        
        /* Compositing */
        #import "fragment_compositing_basic"
        
        if(cdest.w >= 1.0) break;
        rs = rs + rd;
    }
        
    /* Final color */
    cdest = cdest * u_intensity;
    if(cdest.w < 0.01) discard;
    cdest = u_background * (1.0 - cdest.w) + cdest;
    color = cdest;
}

\volumetric_xray.fs
#import "fragment_headers_utils"

void main() {
    #import "fragment_init"
        
    /* Use raymarching algorithm */
    for(int i=0; i<100000; i++){
        vec3 absrs = abs(rs);
        if(i > 1 && (absrs.x > 1.0 || absrs.y > 1.0 || absrs.z > 1.0)) break;
        
        /* Interpolation */
        #import "fragment_interpolation_better"
        
        /* Classification */
        #import "fragment_classification_transfer_function"
        
        /* Compositing */
        #import "fragment_compositing_xray"
        
        if(cdest.w >= 1.0) break;
        rs = rs + rd;
    }
        
    /* Final color */
    cdest = cdest * u_intensity;
    if(cdest.w < 0.01) discard;
    cdest = u_background * (1.0 - cdest.w) + cdest;
    color = cdest;
}

\volumetric_mip.fs
#import "fragment_headers_utils"

void main() {
    #import "fragment_init"
        
    /* Use raymarching algorithm */
    for(int i=0; i<100000; i++){
        vec3 absrs = abs(rs);
        if(i > 1 && (absrs.x > 1.0 || absrs.y > 1.0 || absrs.z > 1.0)) break;
        
        /* Interpolation */
        #import "fragment_interpolation_better"
        
        /* Classification */
        #import "fragment_classification_transfer_function"
        
        /* Compositing */
        #import "fragment_compositing_mip"
        
        if(cdest.w >= 1.0) break;
        rs = rs + rd;
    }
        
    /* Final color */
    cdest = cdest * u_intensity;
    if(cdest.w < 0.01) discard;
    cdest = u_background * (1.0 - cdest.w) + cdest;
    color = cdest;
}

\volumetric_depth.fs
#import "fragment_headers_utils"

void main() {
    #import "fragment_init"
    #import "fragment_postinit_jittering"
        
    /* Use raymarching algorithm */
    for(int i=0; i<100000; i++){
        vec3 absrs = abs(rs);
        if(i > 1 && (absrs.x > 1.0 || absrs.y > 1.0 || absrs.z > 1.0)) break;
        
        /* Interpolation */
        #import "fragment_interpolation_better"
        
        /* Classification */
        #import "fragment_classification_transfer_function"

        /* Compute depth in clip space */
        cdest = csrc;
        gl_FragDepth = ( vec4(rs, 1.0) * u_mvp ).z;
        if(cdest.w >= 0.1){
            break;
        };
        rs = rs + rd;
    }

    /* Final color */
    cdest = cdest * u_intensity;
    if(cdest.w < 0.1) discard;
    color = vec4( vec3( (gl_FragDepth + 1.0) / 2.0 ), 1.0);
}

\debug_volumetric_jittering.fs
#import "fragment_headers_utils"

void main() {
    #import "fragment_init"
    #import "fragment_postinit_jittering"
    #import "fragment_debug_position_entry"
    color = color * u_intensity;
}